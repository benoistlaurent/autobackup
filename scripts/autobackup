#!/usr/bin/env python3

import configparser
import datetime
import subprocess
import logging
import os
import sys


RSYNC_DEFAULT_FLAGS = ['-a', '-v', '--delete']


class RsyncCompletedProcess(subprocess.CompletedProcess):

    @property
    def stdout_str(self):
        return self.stdout.decode('utf-8')

    @property
    def stderr_str(self):
        return self.stderr.decode('utf-8')

    @classmethod
    def from_parent(cls, parent):
        return cls(parent.args, parent.returncode,
                   parent.stdout, parent.stderr)

    def has_errors(self):
        """Return True if rsync exited with errors (return status is not 0)."""
        return self.returncode != 0

    def has_no_space_left_error(self):
        """Return True if a no space left error was detected.
        Check if stderr contains 'No space left on device (28)' or
        'Result too large (34)'.
        """
        return (b'No space left on device (28)' in self.stderr or
                b'Result too large (34)' in self.stderr)

    def print_errors(self):
        print("process standard output:\n{}".format(self.stdout_str), file=sys.stderr)
        print("process error output:\n{}".format(self.stderr_str), file=sys.stderr)

    def assert_has_no_errors(self):
        """Raise an AssertionError return code is not 0."""
        if self.has_errors():
            err = 'rsync process had errors:\n' + self.stderr.decode('utf-8')
            raise AssertionError(err)


def rsync(source, dest, exe='rsync', flags=RSYNC_DEFAULT_FLAGS):
    """Run rsync.

    Args:
        source (str): path to source
        dest (str): path to destination
        exe (str): path to rsync executable
        flags (list[str]): flags to be passed to rsync

    Returns:
        RsyncCompletedProcess: rsync output data.
    """
    cmd = [exe] + flags + [source] + [dest]
    logging.debug("rsync command: {}".format(' '.join(cmd)))
    p = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    logging.debug("rsync process complete")
    return RsyncCompletedProcess.from_parent(p)


def send_email(exp, to, content, subject='', server='localhost'):
    raise RuntimeError("send_email: Not working yet")

    from email.mime.text import MIMEText
    import smtplib

    msg = MIMEText(content)
    msg['Subject'] = subject
    msg['From'] = exp
    msg['To'] = to

    s = smtplib.SMTP(server)
    s.send_message(msg)
    s.quit()


def now(fmt='%y%m%d-%H%M%S'):
    """Return the date as a string in the format `fmt`.
    Args:
        fmt (str): date string format compatible with `datetime.strftime`.
    Returns:
        str: date as a string.
    """
    return datetime.datetime.today().strftime(fmt)


def read_config_file(path):
    logging.info("Read configuration file {}".format(path))
    config = configparser.ConfigParser()
    config.read(path)
    return config


def init_logging():
    """Initialize logging parameters."""
    # Directory where log file will be written.
    logfiledir = '/var/log/autobackup'

    # Log file name is based on current date and time.
    prog = os.path.basename(sys.argv[0])  # program name
    logfile = os.path.join(logfiledir, now() + '_backup.log')
    print("{}: logging to: {}".format(prog, logfile), file=sys.stderr)

    # Initialization itself.
    logging.basicConfig(level=logging.DEBUG,
                        format='%(asctime)s - %(levelname)-8s %(message)s',
                        # filename=logfile,
                        filemode='w')


def backup_from_config(section):
    """Backup from info stored in configuration file section.

    Returns:
        bool: success status
    """
    source = section['source']
    dest = section['dest']
    logging.info("backing up {} to {}".format(source, dest))

    result = rsync(source, dest)

    if result.has_errors():
        message = "error backing up {} to {}:\n{}".format(source, dest, result.stderr_str)
        logging.error(message)
        return False
    
    logging.info("done, no error detected".format(source, dest))
    return True


def main():
    init_logging()
    logging.info("Start time: {}".format(now("%H:%M:%S")))

    # Read configuration file.
    config = read_config_file('config/example.cfg')

    # Actual backup procedure.
    nerrors = 0
    for i, name in enumerate(config.sections()):
        logging.info("----------------------------")

        success = backup_from_config(config[name])
        if not success:
            nerrors += 1

        if i == len(config.sections()) - 1:
            logging.info("----------------------------")

    if nerrors:
        logging.error("{} error{} occured during backup".format(nerrors,
                      's' if nerrors > 1 else ''))
        sys.exit(1)

    logging.info("Backup successful")
    logging.info("End time: {}".format(now("%H:%M:%S")))


if __name__ == '__main__':
    main()
